String built in functions-tolower()-this is used to convert a string to lowercase 
s.substr(start,end-start+1)
isalnum()-this is used to check if the character is alpha numeric
So basically in two pointer we just move one pointer at a time based on some condition and we dont move everything parallelly 
one is in the right the other is in the left.We dont have like a for loop inside the while loop bcs if we basically do it is O(n sq)only
So we just just dont do that
Valid Palindrome 2 is also a palindrome question wherein we do the left <right 
logic only but once we see a mismatch we check if that is a valid palindrome or not by defining another function
Before that TWO POINTER-USED WHEN ARRAY IS SORTED,WE NEED TO COMPARE WITHOUT LOOP,MOVE BASED ON SOME CONDITION
MOVE ONE POINTER AT A TIME
SLIDING WINDOW:
u r working with a subarray/substring, u want max,min,count,longest,shortest
the window is continuous
babad-Longest Palindrome substring(Leetcode 5)
Logic:
so basically the middle letter or the one between that and the other one 
can be the mirror
like palindrome by itself is a mirror
start=i-(len-1)/2 and end=i+len/2 works for odd and even palindromes
if (len>end-start)then find start and end else lite only


u r working with a subarray/substring 
instead of recalculating everything u just expand right or shrink left
it is of two types
fixed-size->first window upto k and put one in and remove the other one.
variable size
left=0
for(right=0->n)
//include s[right]
while(condition breaks)//remove s[left]
left++}
//update ans}
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
f o r g e e k s s k  e  e  g  f  o  r
ab ab a a
preorder means root first 
time complexity to check if a string of length n is a 
palindrome using two pointers from both ends is O(n) it is NOT logn
bcs if it is logn then it shud visit require halving the problem size each step
however we use every n in case of a palindrome for comparing 
learn master's theorem in recursion or recurrence
3 2 1 3 4 k=3
2104)Sum of subarray ranges 
sum of (max-min)over all subarrays
=sum of all subarray maximums-sum of all subarray minimums
Next Greater Element 
The stack that u have to maintain for a 
next greater element is a decreasing stack 
3 1 2 4 
iteration 1:-1    
ple=[-1,-1,1,2]
nle=[1 4 4 4]
Greedy algos:
assign cookies .
to sort:sort(g.begin(),g.end())
pair<int,int> is used to satisfy the pair stuff up



